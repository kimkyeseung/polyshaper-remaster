<template>
  <div class="controller">
    <app-title className="controller__title"/>

    <section v-if="selectedFace" class="controller__section">
      <fieldset>
        <legend class="controller__section_selected-face">Selected Face</legend>
        <div class="input_wrap">
          <input type="color"
            :value="$hexColorFormatter(selectedFace.color)"
            @change="handleColorChange"
          />
        </div>
        <div class="text_wrap">
          <p>{{$hexColorFormatter(selectedFace.color)}}</p>
          <p>{{selectedFace.color}}</p>
        </div>
        <b-button class="button" @click="handleDeselectFace">Deselect</b-button>
        <b-button class="button">Get Color from Image</b-button>
        <b-button class="button danger" @click="handleDelete">Delete Face</b-button>
      </fieldset>
    </section>

    <section class="controller__section">
      <fieldset>
        <legend class="controller__section_background">Background</legend>
        <b-form-checkbox v-model="backgroundVisible" switch>Background Image</b-form-checkbox>
        <label for="opacity" v-if="backgroundVisible">
          Opacity: {{backgroundOpacity}}
          <input
            type="range"
            name="opacity"
            id="opacity"
            min="0.1"
            max="1"
            step="0.1"
            :value="backgroundOpacity"
            @change="handleOpacityChange"
          />
        </label>
        <label for="backgroundColor">
          Fill Background
          <div class="input_wrap">
            <input
              id="backgroundColor"
              type="color"
              value="black"
              ref="backgroundColor"
              @change="handleSelectBackgroundColor"
            />
          </div>
        </label>
      </fieldset>
    </section>

    <section class="controller__section">
      <fieldset>
        <legend class="controller__section_auto-populate">Auto Populate</legend>
        <label for="variance">Variance
          <input
            type="range"
            id="variance"  
            step="0.01"
            min="0"
            max="1"
          />
        </label>
        <label for="cellsize">Cellsize
          <input
            type="range"
            id="cellsize"
            step="2"
            min="10"
            max="200"
          />
        </label>
        <b-button class="button" @click="handleAutoPopulate">Auto Populate</b-button>
      </fieldset>
    </section>

    <section class="controller__section">
      <fieldset>
        <legend class="controller__section_image">Image</legend>
        <b-button class="button" @click="handleImageReset">Image Reset</b-button>
        <b-button class="button">Download Image</b-button>
      </fieldset>
    </section>
  </div>
</template>

<script lang="ts">
import { Vue, Component, Watch } from 'vue-property-decorator';
import imageStore from '@/store/imageStore';
import { AppTitle } from '@/components';
import { Face, Vertex, ColorData } from '@/models/interfaces';
import canvasStore from '../../store/canvasStore';
import polyStore from '@/store/polyStore';

@Component({ components: { AppTitle } })
export default class Controller extends Vue {
  public color = Vue.prototype.$hexColorFormatter('rgb(255, 255, 255)');

  public backgroundOpacity: number = 1;

  public $refs!: {
    backgroundColor: HTMLInputElement;
  }

  get selectedFace(): Face {
    return polyStore.selectedFace;
  }

  get backgroundVisible(): boolean {
    return polyStore.backgroundVisible;
  }

  set backgroundVisible(value: boolean) {
    polyStore.toggleBackgroundVisible(value);
  }

  handleColorChange({ target }: {target: HTMLInputElement}) {
    const color = Vue.prototype.$rgbColorFormatter(target.value);
    polyStore.changeFaceColor(color);
    Vue.prototype.$makeFaceOnCanvas(this.selectedFace, canvasStore.polyCanvas);
  }

  handleOpacityChange({ target }: {target: HTMLInputElement}) {
    this.backgroundOpacity = Number(target.value);
    Vue.prototype.$fillBackgroundColor(this.$refs.backgroundColor.value, canvasStore.backgroundCanvas);
    Vue.prototype.$drawBackgroundImage(undefined, canvasStore.backgroundCanvas, this.backgroundOpacity);
  }

  handleSelectBackgroundColor({ target }: {target: HTMLInputElement}) {
    const color = Vue.prototype.$rgbColorFormatter(target.value);
    Vue.prototype.$clearCanvas(canvasStore.backgroundCanvas);
    Vue.prototype.$fillBackgroundColor(color, canvasStore.backgroundCanvas);
    Vue.prototype.$drawBackgroundImage(undefined, canvasStore.backgroundCanvas, this.backgroundOpacity);
  }

  handleDeselectFace() {
    polyStore.deselectFace();
    Vue.prototype.$clearCanvas(canvasStore.selectedFace);
    Vue.prototype.$clearCanvas(canvasStore.guideCanvas);
  }

  handleDeleteFace() {
    if (!this.selectedFace) {
      return;
    }
    polyStore.removeFace(this.selectedFace);
    this.handleDeselectFace();
    Vue.prototype.$drawAllFaces(canvasStore.polyCanvas, polyStore.faces);
  }

  handleImageReset() {
    imageStore.uploadImage();
    polyStore.initialize();
  }

  handleEscape() {
    this.handleDeselectFace();
  }

  handleDelete() {
    this.handleDeleteFace();
  }

  handleKeyup({ key }: KeyboardEvent) {
    switch (key) {
      case 'Escape':
        this.handleEscape();
        return;
      case 'Delete':
        this.handleDelete();
        return;
      default:
        return;
    }
  }

  handleAutoPopulate() {
    const {
      vertices,
      maxCols,
      maxRows,
      backgroundVariance,
      backgroundCellSize
    } = polyStore;
    const backgroundNodes = Vue.prototype.$autoPopulate({ maxCols, maxRows }, backgroundVariance, backgroundCellSize);
    for (let i = 0; i < backgroundNodes.length; i++) {
      if (backgroundNodes[i].row % 2 === 0 && backgroundNodes[i + maxCols + 1] && backgroundNodes[i].col < maxCols - 1) {
        const v1: Vertex = this.snapChecker(backgroundNodes[i]);
        let v2: Vertex = this.snapChecker(backgroundNodes[i + maxCols]);
        if (v2.next.length) {
          v2 = Object.assign(v2, {next: []});
        }
        const v3: Vertex = this.snapChecker(backgroundNodes[i + maxCols + 1]);
        v1.next.push(v2, v3);
        v2.next.push(v1, v3);
        v3.next.push(v1, v2);
        polyStore.addVertex(v1);
        polyStore.addVertex(v2);
        polyStore.addVertex(v3);
        const color: ColorData = Vue.prototype.$getColorAverage([v1, v2, v3], canvasStore.imageCopy, canvasStore.backgroundCanvas);
        const newFace: Face = {
          faceId: polyStore.faces.length || 0,
          color: Vue.prototype.$stringifyColorData(color),
          vertices: [v1, v2, v3],
        };
        polyStore.addFace(newFace);
        Vue.prototype.$makeFaceOnCanvas(newFace, canvasStore.polyCanvas);
      }
    }
  }

  snapChecker(vertex: Vertex): Vertex {
    const snap: Vertex = polyStore.vertices.getSnapPoint(vertex);
    if (snap) {
      vertex.x = snap.x;
      vertex.y = snap.y;
    }
    return vertex;
  }

  @Watch('backgroundVisible')
  onBackgroundVisibleChanged(value: boolean) {
    if (value) {
      Vue.prototype.$drawBackgroundImage(undefined, canvasStore.backgroundCanvas, this.backgroundOpacity);
    } else {
      Vue.prototype.$clearCanvas(canvasStore.backgroundCanvas);
      Vue.prototype.$fillBackgroundColor(this.$refs.backgroundColor.value, canvasStore.backgroundCanvas);
    }
  }

  created() {
    window.addEventListener('keyup', this.handleKeyup);
  }

  beforeDestroy() {
    window.removeEventListener('keyup', this.handleKeyup);
  }
}
</script>
